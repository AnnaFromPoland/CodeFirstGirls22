Good day!
Because of this homework's structure & purpose description, I researched these questions until I achieved a level of understanding that is satisfactory for me. Below answers have a form of a kind of my inner chatter about that, might include thought process. I hope I got everything correctly :) (if not I hope to receive pointers what have I nisunderstood :) )

### 1 - What is a transcompiler?

Basically the same thing as a compiler.. I don't understand why there is a need to call it a different name. At first it seemed to me like it does the same job as a compiler, and when I googled it up, it turnes that my understanding was correct - I was trying to understand what's a difference between a transpiler, so some device that transcompiles for example JavaScript to Java, so from 1 language to another, and a compiler, which transcompiles Java to machine language or C to machine language etc. - both these actions is still transcompiling 1 language to another language, so really, why when it's languages readable by humans it's "transpiling" and when it's transpiling to machine language it's compiling? Makes no sense to me, it's the same act of translating 1 language to another, sorry but this is silly to me as a translator - it's just as if translating from any language to English would be called "translating" but translating any language to any other language than English would be called something else than translating. This seems to be another antropocentric relict - if humans can read it it's "transpiling" and if we can't it's "compiling" :/ "Transcompiler is a special type of compiler that converts the program's code into another language" - that's what compilers do when they compile C into machine language - machine language is not C... "It can also process a program written in an older version of a programming language, converting it to a newer version of the same language." So it's like "translating" from middle English to modern English... It's a conversion of language version, not even transpiling, transcompiling or translating.
I understand the distinction, that when we convert Python into Java it's transpiling, but when Java gets converted to byte code in JVM it's "compiling" suddenly despite the act of translating 1 source code into other language source code is still the same, I just don't find it useful. Calling all those converstions the same word would have the same effect in human communication.
Source: [What is a transcompiler?](https://www.computerhope.com/jargon/t/transcompiler.htm)

### 2 - What is the difference between Native, Hybrid and Transpiled approaches for Mobile Development?

Native Apps write for 1 target, for example we use Java for Android mobile apps and Objective-C fo iOS apps, while Hybrid would build an app in other technologies (web technologies) and transpile it into Native code (target code, whether our target is Android or iOS) - this allows transpiling the same code intu multiple target builds, while with native approach the code is not similarly reusable with transpiling, to make Kotlin / Android app work in iOS it must be rewritten into Objective-C, not transpiled.
Why would anyone bother with Native apps then? Well, they are written in x language since the beginning, there's nothing lost int ranslation and they will utilise that x language's features best, which translates (yes, I intend my puns) to better performance - so it's a "higher build cost, but better stability and performance" trade-off. "Facebook had a hard time providing a good mobile experience for its users with an hybrid app, and after switching to native apps on both iOS and Android, user satisfaction skyrocketed!"
That said, Hybrid apps _can_ achieve the same performance levels of Native apps, so it's not necessariy that they always work slower or worse. If that'd be the case they would not be used so popularly. Many of the major apps on the market are Hybrid - Instagram, Evernote, LinkedIn for example.
Apparently transpiled apps work (they do) but it's a bit like with Google Translate communication (it works, it's communicative, the message will get through, the app's functionalities will work) versus a real translation (a translator will get all the puns correctly utilising all the language features to their full extent + properly, without a miss, can also create new words if the situation requires it, while a machine has no creativity).
Hybrid apps also have this feature (can be a plus or a minus, depends) of having consistently the same user experience throughout all platforms into which they are transpiled - Native apps might have user experience differences stemming from language differences and thus differences in language features, slight differences in interpretation/implementation of the same functionality.
(Apologies for yet again using a reference to translation business and human languages, I do see some common ground here though with programming languages)
Sources: [Native vs Hybrid & Why should we care?](https://dev.to/antoniovdlc/native-vs-hybrid-do-users-really-care) ; [Hybrid vs Native Apps - What's the difference?](https://www.sfappworks.com/blogs/hybrid-apps-vs-native-apps-whats-the-difference)

### 3 - What is a bridge (in React Native)?
"A React Native app is made up of two sides, the JavaScript side and the Native side. The native side could be Objective-C/Swift for iOS or Java/Kotlin for Android (not to mention the other platforms for React Native like web and desktop). Between the two sides is a bridge, allowing bidirectional and asynchronous communication. Without the bridge, there is no way for the native code to send any information to the JavaScript code and vise versa."
It might be important here to also mention that React Native talks with compilers of the target platforms, so while it has some JS code, it will talk with iOS compiler or Android compiler, not with like 1 universal compiler for all, such a thing doesn't exist, and it also does not translate the code but it talks with the compiler (via a bridge specifically) in order for the compiler to produce a desired result. Roughly putting it, there are 3 layers - React side, bridge and Native side (the iOS or Android side), but we can get into more details here of course on how they talk with eachother - currently I don't think I need any more details though, so I'll leave the link briefly mentioning it but will go on to another point. The data from JS side to Native side seems to be sent using JSON objects for properties and in form of callbacks for functions.
"Many (but not all) React Native npm packages that are added/installed into a project are Native Bridges. If the package is a pure JS package, then that's just what it is - pure JavaScript. If a react-native package contains an `iOS` directory and an `android` directory, it is most likely a Native Bridge." 
Why would anyone need that? Isnt React Native enough?
Well, sometimes yes, sometimes no - there are many React Native modules, but definitely they don't exist for everything, and here's precisely why this bridging ability is helpful - we can access some platform API for which React Native doesn't have an in-built module yet by using bridging, so bridging brings greater customisability. "According to the documentation, React Native team believes that if React Native doesn’t support a native feature that you need, you should be able to build it yourself by using Bridging." 
"There are two ways to bridge native code to JavaScript: 1- Native Modules 2 - Native UI Components". A developer can use them to accesss native features of the target language/platform. "An overview of steps to create a native android module:
1 - Create a java class file that will contain all the native logic you want to execute and variables and callbacks you want to export to JavaScript.
2 - Create a java package for the java class you just created in the previous step and register the module in this package.
3 - Now the last step is to make the package available in the JavaScript code. To do so add your package in the return array of getPackages() method in the MainApplication.java file.
4 - That’s it you have now exported your native module to javascript, to access it we will use NativeModules from React Native."
Sources: [One](https://dev.to/wjimmycook/how-the-react-native-bridge-works-and-how-it-will-change-in-the-near-future-4ekc) ; [Two](https://medium.com/simform-engineering/bridging-for-ios-and-android-in-react-native-64b8ce60a8c2) ; [Three](https://mobilityquotient.com/article/creating-a-native-bridge-in-react-native) ; [Four](https://hackernoon.com/understanding-react-native-bridge-concept-e9526066ddb8) ; [Five](https://tadeuzagallo.com/blog/react-native-bridge) ; [Six](https://www.geeksforgeeks.org/what-is-a-bridge-in-react-native)

### 4 - Why do we develop for mobile platforms? What are some reasons you think we've done this, especially since computers already exist and are considered accessible for many? (Feel free to argue against the question or disagree - simply just make a few points why you think mobile development from off in our world)

Personally, I am quite against great most majority of mobile apps actually. My preferred style of using a mobile phone is for taking photos, messaging, location with Google Maps, playing mp3s and calling (I'm autistic so I'll do everything I can to avoid making calls and I loathe receiving them also). I use my mobile extremely scarcely for those reasons, and also because I find it uncomfortable to use the tiny device for a longer time, I much prefer reading articles on a larger screen, same goes for editing files, doing anything, really. Any action longer than 5 minutes I'll do my best to carry out on a real computer with decently sized monitor - this is comfortable for me.

That said, I can easily understand why certain smaller apps can be useful for other people - they commute, have 30 minutes ot even 60 maybe, and it's unfeasible to use a laptop or maybe even carry it at all times, so they use the mobile for quick entertainment or knowledge. Browsing meme apps, checking social media, checking some recipe or popularly among my friends, playing some simple repetitive game like Angry Birgs or learning some vocabulary using the mobile phone as a flascard device (Anki, Memrise, even Duolingo, many other similar apps) is a fruitful way to spend time, and because the content is not too large, fits nicely on the small screen, this is feasible. Additionally I've observed a habit of "seeking refuge" in the toilet for 40-60minutes of calm mobile browsing (social media, maybe a YouTube video, memes) in MANY men of my generation - it seems widespread, and while me and other girl friends can't understand why that sanctuary of peace has to be on the toilet, we understand the part about needing to shut out and be in peace for some time just doing some mindless browsing.

So considering there are still plenty of use cases where users have some time on their hands, hands free, but are unable or unwilling to open or carry a laptop (a personal computer) and work on it, there is a space for usage for mobile platform applications, and it will not go away so long people commute to school, work or anywhere really, plus there can be also some other uses than during the commuting.

Additionally, the assumption / implication in the question "since computers already exist and are considered accessible for many" is western-world centric - great vast majority of internet usage in Africa and South Asia is still done on mobile devices, and Africa is huge and has a huge population. South Asia actually as well. There are still internet cafes there and not everyone has a computer at their home, plus in Asia people spend a lot of time commuting as well (I'd say more than an average European from what I've experienced, but I've no data on this at hand and it's not so important to verify if it's more or the same amount of time). In Africa mobile internet is sometimes the lifeline and the only window to the outside world.

So there's still a pretty big audience for mobile applications and this won't change anytimes soon. Even though I'm an unlikely customer.

Although yes, one more reason for mobile apps - my FitBit device has a mobile app, because the device itself is so tiny (and should remain so, it's supposed to be a bracelet) that it would be unfeasible to put an app on it. It connects with an app, syncs the data there, and data is displayed in the app, more comfortably than they could be on the tiny device. Some other things can have apps too - for example our washing machine can be launched remotely from an app, that's useful if you want to have the laundry already ready for taking out and drying up when you come back from work and enjoy silence and peaceful rest. So appliances which themselves can't display certain functions might have mobile applications to gain real functional access to new additional functions.

Source: Just my thinking, no outside sources used.

### 5 - Why do we write our React Native code in JSX? What is JSX as well?

JSX is JavaScript with XHTML, it's a more dynamic version of HTML as it allows to inject dynamic tags into HTML like in the below example – vanilla HTML wouldn’t understand this code:

![JSX Beneficial Use Example](jsx.png)

[Source of the example](https://reactjs.org/docs/introducing-jsx.html) - the part about JSX being used in React I remembered from class. In CFG class on React it was actually said that React is JSX, although personally I woudln't say that because React can use JS alone and regular vbanilla HTML or it can use those or also JSX or any mix of these.

I have used this feature several times in referencing dynamic elements in the simple notes app I’ve written in React just to learn via practice. I think this below is another good example of such code, I don’t recall links working this way in vanilla HTML – if I remember correctly they had to be specific locations, either a path (to a folder, and then it reads the index.html of it or whatever is set as the index) or a specific page (like “page.html” or some file or anything, but I don’t recall it using dynamic variables in links – at least not in HTML 2.0, I can’t be sure about 5.0 as I haven’t fully updated my knowledge as there was yet no need to).

![Dynamic Links](notes-example.png)

The link contains a dynamic ID as a part of the link actual.

So I'd say that we use JSX in React Native just because it has added flexibility, allows for more dynamic use of code.

Source: [React's Documentation Part on JSX](https://reactjs.org/docs/introducing-jsx.html) + CFG Class on React

### 6 - Why do we create components? What's the point? Why not just create the entire code logic in one file instead of what is effectively mini lego parts we're combining together?

Short answer, to reuse the code. The whole point of React (and React Native) is to write code that is reusable - so if we write a piece of code for a button or some object, we can then use this very code to render a button again and again anywhere throughout our application. It's different from HTML for example where we would need to copy and paste the whole code in order to "reuse" it, so effectively that's not reusing but using again. Here we can just call on the element to render it. The whole idea of SPA is that the components are kind of like puzzles, so on our langing page we need nav bar, footer and landing page item, then on another page we still call the footer and nav bar again, but instead of the landing page we call other items, some different objects. The mini lego parts are much faster loading than one huge god-file of a code. With HTML and each element needed to be described separately, the files were easily going very long. Chunking code into smaller pieces (by functionalities), encapsulating, abstracting are also just good practices of coding in most if not all OOP languages, and components are definitely chunking the code into smaller pieces, increasing readability of the code itself too as well as through reusability the speed of website/application because it simply weighs less (I recently finished INCO Academy's Green Digital Skills course on green internet, programming, software, process and product design, for final project I've analysed dirties websites. The heavier they get the slower they get and the more CO2 they produce). The concept of components was very neatly explained in CFG React sessions with example graphics from Twitter showing which elements are components and how does that work. i know this answer is very short, but we already had that taught & examined (asked on theory questions) in the Fullstack specialisation + I've written a whole application for handling notes to understand React and its base concepts, I'm satisfied with this knowledge and don't feel any need to go into further details on why components are better, faster and more useful than non-reusable very long god-code rank type of file. 

Source: Just my thinking, no outside sources used.


